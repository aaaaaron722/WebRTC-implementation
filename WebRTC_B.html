<!DOCTYPE html>
<html>
<head>
  <title>WebRTC B with Video</title>
</head>
<body>
  <h1>WebRTC B ç«¯</h1>
  <video id="localVideo" autoplay playsinline muted style="width:300px; border:1px solid #ccc;"></video><br>
  <video id="remoteVideo" autoplay playsinline style="width:300px; border:1px solid #ccc;"></video><br>

  <textarea id="offer" cols="80" rows="10" placeholder="è²¼ä¸Š A çµ¦çš„ Offer"></textarea><br>
  <button onclick="createAnswer()">å»ºç«‹ Answer</button><br><br>

  <textarea id="answer" cols="80" rows="10" placeholder="å»ºç«‹å¾Œçš„ Answer æœƒé¡¯ç¤ºåœ¨é€™ï¼Œè¤‡è£½çµ¦ A"></textarea><br><br>

  <input id="messageInput" placeholder="è¼¸å…¥è¦å‚³é€çš„è¨Šæ¯">
  <button onclick="sendMessage()">é€å‡º</button>

  <h3>æ”¶åˆ°çš„è¨Šæ¯</h3>
  <div id="messages" style="white-space: pre-wrap; border:1px solid #ccc; height:100px; overflow:auto;"></div>

  <script>
    const config = {
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    };
    const remoteConnection = new RTCPeerConnection(config);
    let receiveChannel;

    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");

    // é¡¯ç¤ºæœ¬åœ°åª’é«”æµ
    navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then(stream => {
      localVideo.srcObject = stream;
      stream.getTracks().forEach(track => {
        remoteConnection.addTrack(track, stream);
      });
    }).catch(err => {
      console.error("ç„¡æ³•å–å¾—æœ¬åœ°åª’é«”æµï¼š", err);
      alert("ç„¡æ³•å­˜å–æ”å½±æ©Ÿæˆ–éº¥å…‹é¢¨ï¼Œè«‹æª¢æŸ¥æ¬Šé™è¨­å®šã€‚");
    });

    // æ¥æ”¶é ç«¯çš„åª’é«”æµ
    remoteConnection.ontrack = event => {
      const [stream] = event.streams;
      remoteVideo.srcObject = stream;
    };

    // DataChannel è¨­å®š
    remoteConnection.ondatachannel = e => {
      receiveChannel = e.channel;
      receiveChannel.onmessage = e => {
        document.getElementById("messages").textContent += "ğŸ‘‚ æ”¶åˆ°: " + e.data + "\n";
      };
      receiveChannel.onopen = () => console.log("âœ… DataChannel open!!!!");
      receiveChannel.onclose = () => console.log("âŒ DataChannel closed!");
    };

    // ICE å€™é¸è€…è™•ç†
    remoteConnection.onicecandidate = e => {
      if (!e.candidate) {
        document.getElementById("answer").value = JSON.stringify(remoteConnection.localDescription);
      }
    };

    // å»ºç«‹ Answer
    function createAnswer() {
      const offer = JSON.parse(document.getElementById("offer").value);
      remoteConnection.setRemoteDescription(offer)
        .then(() => remoteConnection.createAnswer())
        .then(answer => remoteConnection.setLocalDescription(answer))
        .catch(err => console.error("å»ºç«‹ answer å‡ºéŒ¯", err));
    }

    // å‚³é€è¨Šæ¯
    function sendMessage() {
      const input = document.getElementById("messageInput");
      if (receiveChannel && receiveChannel.readyState === "open") {
        receiveChannel.send(input.value);
        document.getElementById("messages").textContent += "ğŸ§‘â€ğŸ’» ç™¼é€: " + input.value + "\n";
        input.value = "";
      } else {
        alert("DataChannel é‚„æ²’é–‹å¥½ï¼");
      }
    }
  </script>
</body>
</html>